## 快速排序

### partition(二分)

[5,3,7,2,3,4,1]
目标：将数组中小于等于pivot放左，大于pivot放右边，分两块
设置一个边界：小于等于区域在整个数组的左侧：less
设定pivot = 3
less = -1一开始
i从0开始依次遍历数组

分类讨论：
nums[i] <= pivot : 将当前nums[i]和less区域的下一个数做交换，然后less++扩大less区域，i++
nums[i] > pivot: 什么也不做，i++
当遍历到越界，整个操作停

### partition(三分)

将数组中小于pivot放左，等于pivot放中间，大于pivot放右边
设置两个边界：less，more
less：是小于区域边界 ：往右边扩  : less = left - 1 开始
more：是大于区域边界：往左边扩  : right = nums.length - 1 开始
从i=left开始遍历数组

分类讨论：
nums[i] = pivot : 什么也不做，i++
nums[i] < pivot: 将当前nums[i]和less区域的右一个数做交换，然后less++扩大less区域，i++
nums[i] > pivot: 将当前nums[i]和more区域的左一个数做交换，然后more--扩大more区域，i继续留原地不动，继续看nums[i]

当i和more撞上的时候，停止遍历

#### 三路实质

i来到当前位置，i左侧是小于区域，i右侧有一堆没看的数和大于区域
实际上就是当前i的元素是等于区域的，只需要扩大等于区域就好，i直接++，代码上就是啥没干直接++
如果是nums[i]是小于区域的数，那么就发送这个数到小于区域，推着等于区域往右走
实际上推的动作就是交换等于区域的第一个数，根当前i所在位置交换，然后扩大小于区域
如果是nums[i]是大于区域的数，那么就把这个数发送到大于区域，，然后大于区域推着往左走
实际上推的动作是交换当前i的元素和大于区域的左边一个位置，然后大于区域扩大
但是因为换过来的数没看过，所以i不能动，需要再次查看这个数的情况
